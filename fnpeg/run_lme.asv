%% run_lme.m
%   run lift modulation problem with FNPEG guidance
% 
function dat = run_lme(ICs, planet, veh, guid, integ, lRef, tRef)
% function out = run_lme(ICs, planet, veh, guid, nav, integ, ...
%% Initialization
% Normalize planetary angular velocity
omega = planet.Om * tRef * pi/180;

% Additional reference quantities
vRef = lRef/tRef;
gRef = vRef/tRef;
mRef = veh.m0;

% Normalize thrust and specific impulse
% TMax = veh.TMax / (veh.m0 * gRef);
mDry = veh.mDry / veh.m0;

% Initial range-to-go (deg)
sCur_deg = calc_range(ICs.lat0, ICs.lon0, guid.latT, guid.lonT);

% Pack initial state vector and normalize
x0.sph = [( ICs.h0 + planet.r )/lRef, ICs.lon0 * pi/180, ICs.lat0 * pi/180, ...
    ICs.v0 / (lRef/tRef), ICs.fpa0 * pi/180, ICs.psi0 * pi/180, sCur_deg * pi/180];
x0.cart = mixsph2cart(x0.sph(1:6));
xDyn.sph  = [x0.sph, veh.m0/mRef];    % [r, lon, lat, v, fpa, hea, range, mass]
xDyn.cart = [x0.cart, veh.m0/mRef];   % [x, y, z, vx, vy, vz, mass]
xNav = xDyn;

% Normalize final energy
eF   = guid.eT / (lRef/tRef)^2;

% target to radians
lonT_FNPEG = guid.lonT * pi/180;    %target latitude, rad
latT_FNPEG = guid.latT * pi/180;    %target longitude, rad

% Initial bank angle and direction guesses
bankGuess = guid.bank0;
prevDir = 1;

% Initial bank angle command
bank = guid.bankTrim * pi/180;
direction = 1;

% Set bank profile
bankProfile = guid.bankProfile;

% Set thrust = 0 during entry
a_Thrust = zeros(3,1);

% Normalize and initialize times and time steps
t0 = 0;
tF = integ.tF / tRef;
dt = guid.dt/tRef;
tCur = t0;

% Initialize outputs
nMax = 1000;
ldat1 = nan(nMax, 1);
dat.t = ldat1;
dat.m = ldat1;
dat.r = ldat1;
dat.lon = ldat1;
dat.lat = ldat1;
dat.v = ldat1;
dat.fpa = ldat1;
dat.heading = ldat1;
dat.s = ldat1;

% aux.cart  = zeros(nMax,8); aux.sph  = zeros(nMax,9);
% aux.contr = zeros(nMax,11);
% aux.nav   = zeros(nMax,7);
% aux.meas  = zeros(nMax,7);
% aux.atmo  = zeros(nMax,5);
% aux.pred  = cell(nMax,1);

% Initialize exit criterion, step counter
iter = 1;
% ie = 0;
done = false;

% Integration options
opts = odeset('RelTol', integ.tol, 'AbsTol', integ.tol, ...
    'Events', @(t,x) exit_conditions(t, x, lRef, tRef, 0, eF, mDry, planet, integ));

% Events
% events = struct();

%% Run Simulation Loop
while (~done)
    %% NAVIGATION
    xNav = xDyn;
    
    % Current energy
    eCur = -rv2xi(1, xDyn.sph(1), xDyn.sph(4));
    
    %% GUIDANCE
    switch lower(guid.phase)
        case 'ballistic'
            % Trim bank angle
            bank = guid.bankTrim * pi/180; direction = 1;
            bankProfile = 'constant';
%             
%             % No thrust
%             a_Thrust = zeros(3,1);
%             
%             % Quantities for output
            course = azimuth(xDyn.sph(3)*180/pi, xDyn.sph(2)*180/pi,...
                guid.latT, guid.lonT);
            azOff = wrapTo180(xDyn.sph(6)*180/pi - course);
            deadband = guid.c1 * xDyn.sph(4)*vRef + guid.c0;
            if (tCur >= 0.065)
                % Ensure correct bank profile
                bankProfile = guid.bankProfile;
                
                % Enable termination for final energy
                opts = odeset('RelTol', integ.tol, 'AbsTol', integ.tol, ...
                'Events', @(t,x) exit_conditions(t, x, lRef, tRef, 0, eF,...
                mDry, planet, integ));
            
                % Switch to entry
                guid.phase = 'entry';
                continue
                
            end
        
        case 'entry'
            % FNPEG longitudinal control
            bank = run_fnpeg(bankGuess, tCur, xNav.sph, tCur + tF, lRef,...
                tRef, planet, veh, guid);
            % check bank reversal / deadband
            [direction, course, azOff, deadband] = try_reversal(prevDir, xNav.sph, vRef, guid);
            % save bank profile
            bankProfile = guid.bankProfile;
            % Reset guesses for next iteration
            bankGuess = bank;
            prevDir = direction;
            % Enable termination for final energy
            opts = odeset('RelTol', integ.tol, 'AbsTol', integ.tol, ...
                'Events', @(t,x) exit_conditions(t, x, lRef, tRef, 0, eF,...
                mDry, planet, integ));            
    end    
    % Save output (last step = false)
    dat = store_dat(false, dat, iter, tCur, xDyn, lRef, tRef, bank, ...
    direction, eCur, eF, bankProfile, course, azOff, deadband, ...
    a_Thrust, planet, veh, guid);

    %% DYNAMICS
    
    % Propagate dynamics forward (Cartesian equations)
    [ttCur, xxDyn, ~, ~, ie] = ode45(...
    @(t, x) EOM_unified(t, x, lRef, tRef, bank, ...
    guid.sigmaF, direction, eCur, eF, bankProfile,...
    omega, planet, veh, guid, integ.perts), [tCur, tCur + dt], ...
        xDyn.cart, opts);

    % Advance timestep
    tCur = ttCur(end);
    xDyn.cart = xxDyn(end,:);
    iter = iter + 1;
    
    % Transform to mixed-spherical coordinates
    xDyn.sph(1:6) = cart2mixsph(xDyn.cart(1:6));          % [r, lon, lat, v, fpa, hea]
    xDyn.sph(7) = distance(xDyn.sph(3), xDyn.sph(2), latT_FNPEG, lonT_FNPEG,'radians'); %range
    xDyn.sph(8) = xDyn.cart(7); % mass
    
    %Check exit conditions
    if ~isempty(ie)
        % Terminate integration
        break;
    end
    
end

% save last data point

% Save output (last step = true)
dat = store_dat(true, dat, iter, tCur, xDyn, lRef, tRef, bank, ...
    direction, eCur, eF, bankProfile, course, azOff, deadband, ...
    a_Thrust, planet, veh, guid);

%% FORMAT OUTPUT
%certesian
% aux2 = aux.cart(1:iter,:);
% dat.cart = array2table([aux2(:,1) .* tRef, aux2(:,2:4) .* lRef,...
%     aux2(:,5:7) .* vRef, aux2(:,8) .* veh.m0]);
% 
% % Mixed-spherical trajectory
% aux3 = aux.sph(1:iter,:);
% dat.sph = array2table([aux3(:,1) .* tRef, aux3(:,2) .* lRef,...
%     aux3(:,3:4) .* 180/pi, aux3(:,5) .* vRef, aux3(:,6:7) .* 180/pi, ...
%     aux3(:,8) .* planet.r * 1e-3, aux3(:,8) .* veh.m0]);
% 
% % Control history
% aux4 = aux.contr(1:iter,:);
% dat.controls = array2table([aux4(:,1) .* tRef, aux4(:,2), aux4(:,3:6).*180/pi,...
%     aux4(:,7).*veh.m0.*gRef, aux4(:,8).*veh.m0.*gRef, aux4(:,9:11)]);

end %run_lme.m


function dat = store_dat(last, dat, iter, tCur, xDyn, bank, direction, eCur, course, azOff, deadband, guid)
    %%%store_dat Save output variables into 'aux' structure. Called at
    %%%each timestep.
    %
    % INPUTS:
    %   * last, logical, flag indicating whether this is the last step.
    %
    
    dat.t(iter) = tCur;
    dat.m(iter) = xDyn.sph(8);
    dat.r(iter) = xDyn.sph(1);
    dat.lon(iter) = xDyn.sph(2) * 180/pi;
    dat.lat(iter) = xDyn.sph(3) * 180/pi;
    dat.v(iter) = xDyn.sph(4);
    dat.fpa(iter) = xDyn.sph(5) * 180/pi;
    dat.heading(iter) = xDyn.sph(6) * 180/pi;
    dat.s(iter) = xDyn.sph(7);
    
    if strcmpi(guid.phase,'entry') && ~last
        dat.e(iter) = eCur;
        dat.bank(iter) = direction * bank;
        
        dat.contr(iter,:) = [tCur, eCur, direction*bank, course*pi/180, azOff*pi/180,...
            deadband*pi/180, TMag_cmd, TMag_eff, zeros(1,3)];
    else
        dat.contr(iter,:) = zeros(11,1);
    end
    
    if (last)
        dat.idxend = iter;
    end
end
